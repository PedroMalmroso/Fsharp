\documentclass[a4paper]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for making LaTeX properly handle utf8 characters set and danish language rules
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for changing to a nicer font 
\usepackage [T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for conctroling the text area
\usepackage[margin=2.5cm]{geometry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for inserting clickable hyperlinks in pdf versions as produced by pdflatex
\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for including figures. TeX and thus LaTeX was developped before the existence of directory file-structures, but the graphicspath let's you add directories, that the \includegraphics will search.
\usepackage{graphicx}
\graphicspath{{figures/}{anotherFigureDirectory/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for typesetting programs. Listings does not support fsharp, but a little modification goes a long way
\usepackage{listings}
\usepackage{color}

\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}

\lstdefinelanguage{FSharp}
                {morekeywords={let, new, match, with, rec, open, module, namespace, type, of, member, and, for, in, do, begin, end, fun, function, try, mutable, if, then, else},
    keywordstyle=\color{bluekeywords},
    sensitive=false,
    morecomment=[l][\color{greencomments}]{///},
    morecomment=[l][\color{greencomments}]{//},
    morecomment=[s][\color{greencomments}]{{(*}{*)}},
    morestring=[b]",
    stringstyle=\color{redstrings}
    }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Package for extended math settings, e.g. \eqref
\usepackage{amsmath}
\usepackage{cleveref}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These will be the title and author, as included when \maketitle is called.
\title{Programmering \& ProblemlÃ¸sning | Assignment $3.i$}
\author{Peter Trip Malmroes (WBL189) }
\date{29 September 2023}

\begin{document}
\maketitle % Insert title etc.

\section*{Assignment $3.i.0$}

In this assignment I make the function \verb|makeRandomPositions| which returns a list of $n$ random $(x,y)$-coordinates in a list with a center around $p=(pX,pY)$. All points are contained in a box of dimensions $dp = (dpX,dpY)$. I use the \verb|System.Random()| module to generate (I assume) uniformly distributed integers between an arbitrary integer interval. I construct the intervals from which \verb|System.Random()| draws coordinates such that $p$ is the midpoint. Specifically, the function uses \verb|List.init| resp. \verb|List.map| from the module List to initiate a list of length $n$ resp. fill it with random positions as generated by \verb|System.Random()|. See attached file for XML-documentation. 



\lstset{language=FSharp}
\begin{lstlisting}

let makeRandomPositions (p: int*int) (dp: int*int) (n: int) : ff list =
    let pX, pY = p 
    let dpX, dpY = dp
    let rnd = System.Random()
    let minX = float pX  - float dpX / 2.0 
    let maxX = float pX  + float dpX / 2.0
    let minY = float pY  - float dpY / 2.0
    let maxY = float pY  + float dpY / 2.0
    let nullList = List.init n (fun i -> (0, 0))
    List.map ( fun(x,y) -> (float (rnd.Next(int minX,int maxX)),
            float (rnd.Next(int minY, int maxY)))) nullList
\end{lstlisting}

\pagebreak

\section*{Assignment $3.i.1$}

The function \verb|ofPositions| generates one tree from \verb|generateTree| in which it replicates with different origins as generated by \verb|makeRandomPositions| using \verb|List.Fold|. \verb|List.Fold| defines a random function \verb|fig| which takes the lst generated by \verb|makeRandomPositions| and uses the onto function to recursively put the treeGenerator on fig. Fig starts as an emptyTree (i.e. the accumulator). When folding the list I use the translate function from Canvas to place the tree exactly where the origin $(x,y)$-coordinate as generated by \verb|makeRandomPositions| is. in \cref{fig: Forest} I show the output of 3i1.fsx. 

\begin{lstlisting}
let ofPositions (lst: ff list)  (angles: ff)
 (length: ff) (width: ff) (n: int) : PrimitiveTree =
    let treeGenerator = generateTree (0.0,0.0) angles length width n
    List.fold (fun fig (x,y) -> onto fig (translate x y (treeGenerator)))
     emptyTree lst

\end{lstlisting}

\begin{figure}[h!]
  \includegraphics[width=\linewidth]{Billeder/3i_forest.png}
  \caption{Forest of 20 trees, with 5 branches each.}
  \label{fig: Forest}
\end{figure}

\section*{Assignment $3.i.2$}

\subsection*{Local implementation}

Here the function is called inside \verb|ofPositions|:

\begin{lstlisting}
Let ofPositions (lst: ff list)  (angles: ff) (length: ff) (width: ff)
 (n: int) =
    let tree = generateTree
    <remaining program...>
\end{lstlisting}

\noindent
Each tree can potentially be different if a random or varying parameter is introduced inside generateTree. The local implementation ensures that the tree generation logic is encapsulated within the context of the function. This might be easier for the user of the program to understand what the function does. A local implementation might be less efficient, as the function might be called repeatedly. My implementation is a hybrid implementation as it is called locally within \verb|ofPositions|, but is sort of global in the perspective of the \verb|List.Fold| that I execute in the function. 

\subsection*{Global implementation}

Here the function is called once outside of the function:

\begin{lstlisting}
Let tree = generateTree <parameters here...>

Let ofPositions (lst: ff list)  =
    <remaining program referring directly to tree...>
\end{lstlisting}

\noindent
Here, we ensure efficiency as the tree is only generated once. This is especially fruitful if the generation of the tree is computationally intensive. This, however, can also be seen as a downside as all the trees have to be identical as they are generated globally. I.e. the function is less flexible as compared to its local counterpart. The function is much simpler than the local implementation, which all else equal is an advantage. We thus see a trade-off between simple, traceable functions (global) and flexible, more involved functions (local).

\subsection*{Parameter implementation}

Here the result of \verb|generateTree| is taken as a parameter in the function \verb|ofPositions|:

\begin{lstlisting}

Let ofPositions (lst: ff list) (generateTree ... )  =
    <remaining program using tree as parameter...>
\end{lstlisting}

\noindent
The function generateTree is called once and given as an argument to \verb|ofPositions|. The parameter implementation is thus flexible and consistent as the tree can be generated once (consistent), but can be replaced by generating a different tree and passing it as an argument (flexible). This also makes the function more reusable, as \verb|ofPositions| can be called with different tree generators, i.e. if I were to make another kind of tree I could pass that as an argument and reuse \verb|ofPositions|. 

\end{document}

